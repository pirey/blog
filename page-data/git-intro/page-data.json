{"componentChunkName":"component---src-templates-blog-post-js","path":"/git-intro/","result":{"data":{"site":{"siteMetadata":{"title":"Yeri's Blog"}},"markdownRemark":{"id":"09dcd064-ab55-59d2-8247-3fcf3d800a22","excerpt":"Keep track of our works (man git) Git is a command line application, meaning it’s an application that we run in the terminal / command prompt. The purpose of…","html":"<h2>Keep track of our works (man git)</h2>\n<p>Git is a command line application, meaning it’s an application that we run in the terminal / command prompt.</p>\n<p>The purpose of git is to keep track of our works. As a programmer, what we usually do at work is write code. With git, we can see what are the things that we added, edited, or removed from our project’s source code.</p>\n<p>By default, git doesn’t just track everything we do to our source code. Therefore we need to tell git which changes we made to the source code that we want to keep track later, as we discuss later.</p>\n<h2>Get a repo (git init, clone)</h2>\n<p>A repository (or repo) is basically a project containing source codes that is tracked by git.</p>\n<p>There’s two main way to get a git repo. First, we can create our brand new project and tell git to keep track of it. Or, we can grab other people’s project that is already tracked by git somewhere.</p>\n<p>To use the first method:</p>\n<ul>\n<li>We can create new project or we can use any existing project which hasn’t been tracked by git</li>\n<li>Navigate to project directory via terminal / command prompt, <code class=\"language-text\">cd &lt;project_dir&gt;</code></li>\n<li>Run <code class=\"language-text\">git init</code></li>\n</ul>\n<p>To use the second method:</p>\n<ul>\n<li>Search for any git project, e.g from github</li>\n<li>And then run <code class=\"language-text\">git clone &lt;repo_url&gt;</code></li>\n<li>This will download the project into our local machine</li>\n</ul>\n<h2>Introduce yourself (git config)</h2>\n<p>Because, beside keeping track of changes in a repo, git also keep track of who did the changes.</p>\n<p>Therefore, before we make any changes to the project, we have to introduce ourselves, well, at least we tell our name and email so git can identify us.</p>\n<p>To do that we can run this command</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git config --global user.name=&quot;Your Name&quot;\ngit config --global user.email=&quot;your.email@somewhere.com&quot;</code></pre></div>\n<h2>Pick and keep (git status, add, commit)</h2>\n<p>There are at least 3 kinds of changes that we usually do to when we write code: creating, editing, or deleting files.</p>\n<p>For illustration, let say we create some new files in our repo: <code class=\"language-text\">file_a.txt</code>, <code class=\"language-text\">file_b.txt</code>, and <code class=\"language-text\">file_c.txt</code>. After we created those files, however, git still doesn’t know a thing about them. If we want git to keep track of the new files, we have to tell git to ‘record’ it.</p>\n<p>The basic flow is:</p>\n<ul>\n<li>We made changes (add, edit, or delete)</li>\n<li>We ‘pick’ which changes we want git to ‘record’, using <code class=\"language-text\">git add</code> command</li>\n<li>Finally we tell git to <code class=\"language-text\">record</code> the changes, using <code class=\"language-text\">git commit -m &quot;&lt;commit message&gt;&quot;</code> command</li>\n</ul>\n<p>Continuing the illustration, let say we only want to keep track of <code class=\"language-text\">file_a.txt</code>, so the steps is:</p>\n<ul>\n<li>Run <code class=\"language-text\">git add file_a.txt</code></li>\n<li>Then run <code class=\"language-text\">git commit -m &quot;add file_a to the repo&quot;</code></li>\n</ul>\n<p>A commit is set of changes that git record, and the commit message can be used to add remarks of what we do in a commit.</p>\n<p>So what happens to <code class=\"language-text\">file_b.txt</code> and <code class=\"language-text\">file_c.txt</code>? Well, they’re fine and they’re still in our repo, but git still doesn’t know a thing about them.</p>\n<p>One way to know the status of changes in our repo is to use the <code class=\"language-text\">git status</code> command. It will output current changes that happen, whether we add new files, edit some existing files (that is already tracked by git), or delete some files.</p>\n<p>If we run <code class=\"language-text\">git status</code>, git will tell us that <code class=\"language-text\">file_b.txt</code> and <code class=\"language-text\">file_c.txt</code> is ‘untracked’, meaning git doesn’t know about it yet.</p>\n<p>If we run <code class=\"language-text\">git add file_b.txt</code>, and then run <code class=\"language-text\">git status</code> again, now git will tell that <code class=\"language-text\">file_b.txt</code> is ‘ready to be committed’, meaning we have ‘picked’ which changes that we want git to record.</p>\n<p>Then, if we run <code class=\"language-text\">git commit -m &quot;add file_b&quot;</code>, and then run <code class=\"language-text\">git status</code> again, <code class=\"language-text\">file_b.txt</code> is now dissapear from the output, just like <code class=\"language-text\">file_a.txt</code> previously. Because <code class=\"language-text\">git status</code> only tells us about what are the current changes that happens in the repo, and since <code class=\"language-text\">file_a.txt</code> and <code class=\"language-text\">file_b.txt</code> has now tracked by git, it doesn’t appear in the output.</p>\n<p>Right now, if we edit the content of <code class=\"language-text\">file_c.txt</code>, and then run <code class=\"language-text\">git status</code> git will always tells us it is ‘unstaged’, because there’s no information about the file whatsoever. However, if we edit <code class=\"language-text\">file_a.txt</code> or <code class=\"language-text\">file_b.txt</code>, and then run <code class=\"language-text\">git status</code>, git will tell us that its ‘modified’, because git has a way to compare the file content with the content from latest commit.</p>\n<h2>Reading history (git log)</h2>\n<p>The essentials of using git is to create a series of commits. For a reminder, a commit contain information of a change that we made.</p>\n<p>To see commits in a repo, we run <code class=\"language-text\">git log</code> command. It will display list of commits so far in the repo.</p>\n<p>As we can see, each commit contain additional information, like the commit <code class=\"language-text\">hash</code> or commit id, the commit message, the commit date, and the author. It also contain other stuff that we don’t need to focus right now. Later we can use this information to further manipulate our repo.</p>\n<p>Tips: we can use <code class=\"language-text\">git log --oneline</code> to display each commit in one line, so we can have a better view when we have a lot of commits.</p>\n<h2>Another place to keep (git remote)</h2>\n<p>Another purpose of git is to make collaboration with other people easier. So far, we only work alone, in our local machine, but we need to share our work with others. For that purpose, git let us ‘copy’ our repo to other location with the concept of <code class=\"language-text\">remote</code>.</p>\n<p>A remote can be thought as a place where the ‘copy’ of our local repo is kept. The idea is, it contains all commits from our local repo and can be located anywhere on the internet, so that other people can have access to it. Since other people can have access to it, it means they can do their work and create their commits and then we can collaborate.</p>\n<p>We can setup our own server to host the remote repo, or we can just use third party service. One of the most popular service is github.com.</p>\n<p>To ‘connect’ our repo to a remote, first we need to create a pointer to a remote.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git remote add origin &lt;url&gt;</code></pre></div>\n<p>The <code class=\"language-text\">&lt;url&gt;</code> is where the remote repo is, and <code class=\"language-text\">origin</code> is the name of the pointer that points to that <code class=\"language-text\">&lt;url&gt;</code>. The <code class=\"language-text\">origin</code> can be thought as ‘nickname’ for a remote, so later if we want to refer to that url we can refer to the ‘nickname’ instead.</p>\n<p>We can have more than one remote repo, for example if we want to ‘connect’ our repo to another remote repo, we can run:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git remote add other_remote &lt;url&gt;</code></pre></div>\n<p>We can give nickname to the remote as we want, as long as it doesn’t clash with other remote name. The term <code class=\"language-text\">origin</code> in the first example is conventional, indicating that it is the ‘main’ remote.</p>\n<p>Now that we have a remote repo, we can ‘upload’ our changes to the remote repo. To do so, we use the <code class=\"language-text\">git push</code> command, for example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git push origin master</code></pre></div>\n<p>Again, the <code class=\"language-text\">origin</code> is the name of the remote, while <code class=\"language-text\">master</code> is the name of the target branch we want to upload to.</p>\n<p>After we ‘upload’ our changes to remote repo, other people who want to collaborate with us can download the latest changes by ‘downloading’ it from the repo.</p>\n<p>To get latest changes from remote repo, we can use <code class=\"language-text\">git pull</code> command, for example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git pull origin master</code></pre></div>\n<h2>Time travel (HEAD)</h2>\n<p>We have learned previously that we can view history of commits using <code class=\"language-text\">git log</code>. What if I told you that we can also ‘go back’ to any of those commits?</p>\n<p>For illustration, we run <code class=\"language-text\">git log --oneline</code> and these are the commits that we have:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1234d commit 4\n1234c commit 3\n1234b commit 2\n1234a commit 1</code></pre></div>\n<p>This tells us that the latest commit <code class=\"language-text\">hash</code> is <code class=\"language-text\">1234d</code> with the message <code class=\"language-text\">commit 4</code>. The latest commit when we run <code class=\"language-text\">git log</code> is the current structure or content of our repo.</p>\n<p>Let say we want to ‘undo’ the changes in <code class=\"language-text\">commit 4</code>, and ‘go back’ to <code class=\"language-text\">commit 3</code>, what we can do is run this command:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git reset --hard 1234c</code></pre></div>\n<p>This command will make <code class=\"language-text\">commit 3</code> the latest commit, and if we run <code class=\"language-text\">git log --oneline</code> again, the <code class=\"language-text\">commit 4</code> is now dissapear:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1234c commit 3\n1234b commit 2\n1234a commit 1</code></pre></div>\n<p>Git has a pointer called <code class=\"language-text\">HEAD</code>. The purpose of <code class=\"language-text\">HEAD</code> is to indicate what is the current structure of our project. We can think of our repo as a series of commits and by default <code class=\"language-text\">HEAD</code> is always pointing to the latest commit.</p>\n<p>In the previous example, we can also think of what we have done as ‘moving’ the <code class=\"language-text\">HEAD</code> to points to the previous commit, so that the previous commit became the ‘latest’ commit.</p>\n<p>We can tell git to display where the <code class=\"language-text\">HEAD</code> is using this command:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git log --oneline --decorate</code></pre></div>\n<p>The <code class=\"language-text\">--oneline</code> will output one commit per line, and the <code class=\"language-text\">--decorate</code> will display the <code class=\"language-text\">HEAD</code> and some other information.</p>\n<h2>Alternate reality (git branch)</h2>\n<p>When we build an application, sometimes we need to add features, or maybe fixing bugs. When we make changes, we tend to also make mistakes. We don’t want the changes that we made to break the current application. We need a way to make changes and test the changes afterward in ‘isolation’, and then combine the changes back.</p>\n<p>We can think of series of commits that we made so far as a ‘timeline’. What we need to do is to create separate ‘timeline’. This concept of separate path to make changes is called <code class=\"language-text\">branch</code> in git. With <code class=\"language-text\">branch</code> we can create multiple series of commits where each timeline has its own set of changes.</p>\n<p>By default, when we create new project using <code class=\"language-text\">git init</code> we only have one <code class=\"language-text\">branch</code> with the name of <code class=\"language-text\">master</code>. That is where we previosly create our commits. To make a new <code class=\"language-text\">branch</code>, we use <code class=\"language-text\">git branch</code> command, for example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git branch develop</code></pre></div>\n<p>Now we have a new <code class=\"language-text\">branch</code> called <code class=\"language-text\">develop</code>.</p>\n<p>Previously, we only have one branch, <code class=\"language-text\">master</code>, and everytime we make changes, the commit will be added to the <code class=\"language-text\">master</code> branch timeline. Now that we have more than one <code class=\"language-text\">branch</code>, every changes will be added to whichever <code class=\"language-text\">branch</code> is currently ‘active’. And right now the active branch is still the <code class=\"language-text\">master</code> branch, because the previous command only create the <code class=\"language-text\">develop</code> branch but not yet activating it.</p>\n<p>If you still remember our discussion about <code class=\"language-text\">HEAD</code> in the previous section, the <code class=\"language-text\">HEAD</code> is pointing to the latest commit. But previously, since we only have one branch, the <code class=\"language-text\">HEAD</code> is pointing to the latest commit on the <code class=\"language-text\">master</code> branch. The active branch is determined by where the <code class=\"language-text\">HEAD</code> points to. Because the <code class=\"language-text\">HEAD</code> still points to <code class=\"language-text\">master</code>, that means <code class=\"language-text\">master</code> is the ‘active’ branch. We can move the <code class=\"language-text\">HEAD</code> to points to another branch by using <code class=\"language-text\">git checkout</code> command. For example if we want to activate <code class=\"language-text\">develop</code> branch, we can use this command:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git checkout develop</code></pre></div>\n<p>From now on, if we create new commits, it will be added to the <code class=\"language-text\">develop</code> branch and the <code class=\"language-text\">master</code> branch will not know any changes we made in <code class=\"language-text\">develop</code> branch.</p>\n<p>For example, the <code class=\"language-text\">master</code> branch have:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">file_a.txt\nfile_b.txt\nfile_c.txt</code></pre></div>\n<p>If we <code class=\"language-text\">checkout</code> the <code class=\"language-text\">develop</code> branch and add new files to our project and commit the changes:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">file_a.txt\nfile_b.txt\nfile_c.txt\n\nfile_x.txt\nfile_y.txt\nfile_z.txt</code></pre></div>\n<p>Now, if we <code class=\"language-text\">checkout</code> the <code class=\"language-text\">master</code> branch again using <code class=\"language-text\">git checkout master</code>, we won’t see the newly added files. The files in the <code class=\"language-text\">master</code> branch is still the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">file_a.txt\nfile_b.txt\nfile_c.txt</code></pre></div>\n<p>This is because <code class=\"language-text\">master</code> and <code class=\"language-text\">develop</code> each have their own ‘version’ of project structure and contents.</p>\n<p>When we finish the development in the <code class=\"language-text\">develop</code> branch, after testing it and feeling confident about the changes, we can combine the two branch together. We do so by first checking out the target branch, which is the branch that we want to receive the changes, and then run <code class=\"language-text\">git merge &lt;source_branch&gt;</code> command.</p>\n<p>For example, if we want to merge all the changes from <code class=\"language-text\">develop</code> branch back to our <code class=\"language-text\">master</code> branch, first we checkout <code class=\"language-text\">master</code> branch</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git checkout master</code></pre></div>\n<p>And then we run:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git merge develop</code></pre></div>\n<p>Now the structure of our project become:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">file_a.txt\nfile_b.txt\nfile_c.txt\n\nfile_x.txt\nfile_y.txt\nfile_z.txt</code></pre></div>\n<p>Git is smart enough to detect any duplicate files, therefore if two branches contains files with same name, if the content of those files is the same, git will think its safe to ignore it and leave the file as it is.</p>\n<p>If the two branches contain files with same name but different content, git can detect the difference and automatically combine the content of the file properly if it can.</p>\n<p>Now that we have more than one branch, we can also <code class=\"language-text\">push</code> to or <code class=\"language-text\">pull</code> from specified branch. For example <code class=\"language-text\">git pull origin develop</code> will get any changes from <code class=\"language-text\">origin</code> remote, from <code class=\"language-text\">develop</code> branch in the remote. Or <code class=\"language-text\">git push origin develop</code> to push our local changes to <code class=\"language-text\">develop</code> branch in the remote.</p>","frontmatter":{"title":"Git intro","date":"June 13, 2019","description":"An awesome introduction to git, you should definitely read it."}}},"pageContext":{"slug":"/git-intro/","previous":{"fields":{"slug":"/making-sense-of-using-redux-in-react/"},"frontmatter":{"title":"Making sense of using Redux in React"}},"next":{"fields":{"slug":"/catch-multiple-exception-in-javascript-with-union-type/"},"frontmatter":{"title":"Catch multiple exception in javascript with union type"}}}},"staticQueryHashes":["1246554614","2841359383"]}